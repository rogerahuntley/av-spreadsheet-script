import time, sys, pickle
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException

#if something fails and calls an exception, exit application
class CException(Exception):
    pass

#defining default settings
browser = None
wait = None
date = 0
month = "Jun"

#event array for all events, used as a placeholder to generate the spreadsheet
events = []

#object for an entry to the sheeets
class SheetEntry():

    #for the open times
    availbefore = "error"
    availafter = "error"
    #for if theres a janky date
    dateend = ""
    datestart = ""

    #variables generated by when the program finds the event initially
    def __init__(self, starttime, endtime, classroom, eventsum, resources, instructions):
        self.starttime = starttime
        self.endtime = endtime
        self.classroom = classroom
        self.eventsum = eventsum
        self.resources = resources
        self.instructions = instructions
        print("adding event: " + str(starttime) + " " + str(endtime) + " " + str(classroom) + " " + str(eventsum) + " " + str(resources) + " " + str(instructions))
    
    #prints data 
    def printall(self):
        print(str(self.starttime) + " " + str(self.endtime) + " " + str(self.classroom) + " " + str(self.eventsum) + " " + str(self.resources) + " " + str(self.instructions) + " " + str(self.availbefore) + " " + str(self.availafter))

#removes am or pm from a time if its 3 characters instead of 4
#examples: 11:00 is 5 characters, but 9:00 is only 4, so it might come out as 9:00a instead
#this fixes that
def removeap(word):
    word = word.replace("a", "")
    word = word.replace("p", "")
    word = word.strip()
    return word

def openbrowser():
    delay = 10 # seconds

def stripX(string):
    newstring = string.replace("X0", "").replace("X", "")
    return newstring

def ceil_dt(dt, res):
    # how many secs have passed this day
    res = datetime.timedelta(minutes=res)
    nsecs = dt.hour*3600 + dt.minute*60 + dt.second + dt.microsecond*1e-6
    delta = res.seconds - nsecs % res.seconds
    if delta == res.seconds:
        delta = 0
    return dt + datetime.timedelta(seconds=delta)

def floor_dt(dt, res):
    # how many secs have passed this day
    res = datetime.timedelta(minutes=res)
    nsecs = dt.hour*3600 + dt.minute*60 + dt.second + dt.microsecond*1e-6
    delta = nsecs % res.seconds
    return dt - datetime.timedelta(seconds=delta)

###stolen from https://gist.github.com/comargo/16c049f14381f7789c8a1de239ad133e

def waitForXPath(element):
    hidden = True
    elements = browser.find_elements_by_xpath(element)
    while len(elements) < 1 or hidden:
        try:
            hidden = not elements[0].is_displayed()
        except:
            pass
        elements = browser.find_elements_by_xpath(element)
        print("waiting for: " + element)

    # should return false
    return hidden

def loadLoop(element):
    loading = False

    # get all elements as array
    elements = browser.find_elements_by_class_name(element)

    #if there are none, done loading
    if len(elements) > 0:
        loading = True
        print("waiting for element: " + element)
        while len(elements) > 0:
            try:
                test = elements[0].is_displayed() # crashes if no elements
                elements = browser.find_elements_by_class_name(element)
            except:
                elements = []
            print("waiting")

    # returns true if it had to wait
    return loading

#this function gives the browser time to load and checks the elements before proceeding - avoids not being able to click elements because they're covered by a "loading" div
def load():
    loading = True
    wa = "waiting for element: "
    fa = "failed to find element: "
    while loading:
        loading = False
        #sLoading
        if(loadLoop("sLoading") == True):  
            loading = True
        if(loadLoop("s25-busy-cursor") == True):  
            loading = True
        #bxloading1
        bx = False
        try:
            bx = browser.find_element_by_id("bxLoading").is_displayed()
        except:
            pass
        loading = loading or bx
        if bx:
            print(wa + "bxLoading")
            try:
                wait.until(EC.invisibility_of_element_located((By.ID, "bxLoading")))
            except:
                print(fa + "bxLoading")
                pass
        #ApplicationShade
        AS = False
        try:
            AS =  browser.find_element_by_id("ApplicationShade").is_displayed()
        except:
            pass
        loading = loading or AS
        if AS:
            print(wa + "ApplicationShade")
            try:
                wait.until(EC.invisibility_of_element_located((By.ID, "ApplicationShade")))
            except:
                print(fa + "ApplicationShade")
                pass

#code that types in your info and signs you in
def signin(username, password):
    load()
    signin = wait.until(EC.presence_of_element_located((By.LINK_TEXT, "Sign In")))    
    time.sleep(10)
    wait.until(EC.element_to_be_clickable((By.LINK_TEXT, "Sign In")))
    wait.until(EC.invisibility_of_element_located((By.ID, "bxLoading")))
    signin.click()
    usernameu = wait.until(EC.element_to_be_clickable((By.ID, "LoginUserName")))
    usernameu.send_keys(username)
    passwordu = wait.until(EC.element_to_be_clickable((By.ID, "LoginPassword")))
    passwordu.send_keys(password)
    time.sleep(5)
    confirm = wait.until(EC.element_to_be_clickable((By.ID, "LoginBtn")))
    confirm.click()
    #savesession()

#this code goes through the event list and adds most of the information to the array of all events
def setuparray():
    print("setting up array")
    wait.until(EC.presence_of_element_located((By.CLASS_NAME, "CalendarCellToday")))
    wait.until(EC.presence_of_element_located((By.CLASS_NAME, "CalendarDayEventItem")))
    #wait until the event items are available
    print("Daily Event Table Found!")
    print(date)
    if (str(date) == "1"):
        eventxpath = "//div[contains(@id,'layout-tabbox-groups')]/div[contains(@style,'display: block')]//td[contains(concat(' ',normalize-space(@class),' '),' CalendarCell ')][contains(.//div[@class='CalendarDayHeader MonthName'],'"+str(date)+"')]/div[contains(@class, 'CalendarDayEvents')]"
    else: 
        eventxpath = "//div[contains(@id,'layout-tabbox-groups')]/div[contains(@style,'display: block')]//td[contains(concat(' ',normalize-space(@class),' '),' CalendarCell ')][contains(.//div[@class='CalendarDayHeader'],'"+str(date)+"')]/div[contains(@class, 'CalendarDayEvents')]"
    print(eventxpath)
    wait.until(EC.presence_of_element_located((By.XPATH, eventxpath)))
    #wait until the specified day has been found
    print("# of collumns with this date found: " + str(len(browser.find_elements_by_xpath(eventxpath))) + "  Note: this should only ever be 1")
    #print number of days found
    eventlist = browser.find_element_by_xpath(eventxpath)
    #set the web element holding all the events to a variable
    allevents = eventlist.find_elements_by_xpath("./*")
    #get all the seperate web elements holding the events and adds them to a list
    print("# of events found: " + str(len(allevents)))
    #print the number of events found
    for event in allevents:
        try:
            datestart = ""
            dateend = ""
            eventcount = len(events)
            if eventcount == 1:
                writexl(events, eventcount)
            if eventcount % 10 == 1:
                writexl(events, eventcount)
            wait.until(EC.presence_of_element_located((By.CLASS_NAME, "CalendarCellToday")))
            wait.until(EC.presence_of_element_located((By.CLASS_NAME, "CalendarDayEventItem")))
            #wait until the event ites are available
            print("Daily Event Table Found!")
            eventsum = event.find_element_by_class_name("summary").text
            print("found summary: " + eventsum)
            starttime = event.find_element_by_xpath("./span[1]").text
            print("found start time: " + starttime)
            if len(starttime) > 8:
                #
                # come back here later to parse long term memes
                #
                datestart = starttime[7:].replace("(", "").replace(")", "")
                starttime = datetime.datetime.strptime(starttime[:7].strip().upper(), "%I:%M%p")
                print("date start: " + datestart)
            else:
                starttime = datetime.datetime.strptime(starttime.upper(), "%I:%M%p")
            endtime = event.find_element_by_xpath("./span[2]").text
            print("found end time: " + endtime)
            if len(endtime) > 8:
                #
                # come back here later to parse long term memes
                #
                endtime = datetime.datetime.strptime(endtime[:7].strip().upper(), "%I:%M%p")
            else:
                endtime = datetime.datetime.strptime(endtime.upper(), "%I:%M%p")
            #get the basic information from the event list
            rooms = event.find_elements_by_xpath("./div[@class='icon-space']/span")
            roomsshort = []
            roomslong = []
            for room in rooms:
                roomsshort.append(room.text[5:9])
                print(room.text)
                roomslong.append(room.text)
            if roomslong:
                summary = scraperesources(event, starttime, endtime, roomslong, datestart, dateend)
                resources = summary[0]
                instructions = summary[1]
                entry = SheetEntry(starttime, endtime, roomsshort, eventsum, resources, instructions)
                if datestart != "":
                    entry.datestart = datestart
                if dateend != "":
                    entry.dateend = dateend
                events.append(entry)
                print(entry.datestart)
        except:
            print("big seth")
        #for some reason, clicking the close button doesn't always work. the code below pretty much brute-forces it until the main event pages is loaded
        closexpath ="//div[@*[name()='c:id']='Details']//div[@class='viewOptions']/div[contains(concat(' ',normalize-space(@class),' '),' viewOption_Close ')]//a//img"
        clickxpath(closexpath)
        load()
    for event in events:
        event.printall()

#this is a subfunction of the last, actually goes into the details of each room to gather all of the data
def scraperesources(event, starttime, endtime, rooms, datestart, dateend):
    starttime = stripX(datetime.datetime.strftime(starttime, "X%I:%M %p"))
    endtime = stripX(datetime.datetime.strftime(endtime, "X%I:%M %p"))
    #initializes the list that contains everyting to return to the main function
    summary = []
    #initializes the list of resources
    resources = []
    #initializes the list of instructions
    instructions = []
    #clicks on the specific event for more information
    print("event: " + event.text)
    time.sleep(1)
    clickfromevent(event)
    time.sleep(1)
    print("waiting for main elements to show up")
    waitpath = "//a[contains(concat(' ',normalize-space(@class),' '),' col-title ')]"
    wait.until(EC.presence_of_element_located((By.XPATH, "//div[contains(@class,'tb-col s25ph-title ng-binding')]")))
    time.sleep(2)
    wait.until(EC.presence_of_element_located((By.XPATH, "//div[contains(@class,'tb-col s25ph-title ng-binding')]")))
    otheroccur = browser.find_elements_by_xpath(waitpath)
    print("expanding for before and after")
    for occur in otheroccur:
        occur.click()
    #finds element specific to the event, narrowing down the options to grab the one with the specific time and room number
    xpathbefore = ""
    xpathafter = ""
    monthdate = ""
    if datestart != "":
        monthdate = datestart
        print("datestart: yes " + datestart)
    else:
        print("datestart: " + datestart)
        dateadd = str(date)
        if str(len(date)) == "1":
            dateadd = "0" + dateadd
        monthdate = month + " " + dateadd + " "
    if len(rooms) > 1:
        xpath = "//div[@class='tb-body'][contains(div, ' " + monthdate + "')][contains(.,'" + removeap(starttime[0:5]) + "')][contains(.,'" + removeap(endtime[0:5]) + "')][contains(.,'(" + str(len(rooms)) + " locations)')]"
    else:
        xpath = "//div[@class='tb-body'][contains(div, ' " + monthdate + "')][contains(.,'" + removeap(starttime[0:5]) + "')][contains(.,'" + removeap(endtime[0:5]) + "')][contains(.,'" + rooms[0] + "')]"
    #REMOVE LATER
    debug = False
    if debug:
        print(event.text, file=open("output"+str(len(events))+ ".txt", "w+"))
    print("xpath: " + xpath)
    print("waiting to find xpath")
    try:
        expandingrare = "//div[contains(@class, 'item-text') and contains(text(),'locations')]"
        browser.find_element_by_xpath(expandingrare)
        clickxpath(expandingrare)
    except:
        print("no worries")
    while len(browser.find_elements_by_xpath(xpath)) < 1:
        load()
        print("waiting for xpath again")
    print("found xpath")
    reservation = browser.find_element_by_xpath(xpath)
    #
    #looks to see if the resource list needs to be expanded; if so, it needs to parse the resource information different
    xpathforE = "/div/div[contains(concat(' ',normalize-space(@class),' '),' icon-plus ')]"
    xpathforR = "//div[@class='left-icon-row'][div/div/div[contains(concat(' ',normalize-space(@class),' '),' icon-resource ')]]"
    xpathforI = "//div[contains(concat(' ',normalize-space(@class),' '),' item-instruction ')]/div[contains(concat(' ',normalize-space(@class),' '),' item-text ')]"
    #expand = reservation.find_elements_by_xpath(xpath + xpathforE)
    expand = False
    if len(browser.find_elements_by_xpath(xpath + xpathforE)) > 0:
        print("needs to be expanded")
        clickxpath(xpath + xpathforE)
        xpathfluid = "//div[@class='container-fluid'][contains(.,'" + rooms[0] + "')]"
        resourceelements = browser.find_elements_by_xpath(xpathfluid + xpathforR)
        instructionelements = browser.find_elements_by_xpath(xpathfluid + xpathforI)
    else:
        resourceelements = reservation.find_elements_by_xpath(xpath + xpathforR)
        instructionelements = reservation.find_elements_by_xpath(xpath + xpathforI)
    print(resourceelements)
    for resource in resourceelements:
        print(resource.text)
        resources.append(resource.text)
    for instruction in instructionelements:
        print(instruction.text)
        instructions.append(instruction.text)
    summary.append(resources)
    summary.append(instructions)
    return summary
    #$x("//div[@class='let-icon-row'][//div[contains(concat(' ',normalize-space(@class),' '),' icon-resource ')]]")

#goes through each event and checks the location for other classes
def opentimes():
    changetab("locations")
    for event in events:
        start = event.starttime
        end = event.endtime
        availability = [];
        if event.classroom[0] == "B119":
            availability = ["OPEN", "OPEN"]
        else:
            availability = searchroom(event.classroom[0], start, end)
        event.availbefore = availability[0]
        event.availafter = availability[1]

#this is called once per event, checks the rooms and returns if there's a class before or after
def searchroom(room, nstart, nend):
    if True:
        start = nstart
        print(str(start))
        end = nend
        print(str(end))
        print(room)
        roomsearch = wait.until(EC.element_to_be_clickable((By.ID, "space_search_keyword")))
        browser.execute_script("arguments[0].value = ''", roomsearch)
        roomsearch.send_keys(room)
        load()
        time.sleep(1)
        confirm = wait.until(EC.element_to_be_clickable((By.XPATH, "//div[contains(@id,'s25_space_search')]//span[contains(concat(' ',normalize-space(@class),' '),' sentenceNav_SearchGo ')]")))
        time.sleep(1)
        confirm.click()
        time.sleep(3)
        wait.until(EC.presence_of_element_located((By.CLASS_NAME, "CalendarCellToday")))
        wait.until(EC.presence_of_element_located((By.CLASS_NAME, "CalendarDayEventItem")))
        #wait until the event items are available
        print("Daily Event Table Found!")
        if (str(date) == "1"):
            eventxpath = "//div[contains(@id,'layout-tabbox-groups')]/div[contains(@style,'display: block')]//td[contains(concat(' ',normalize-space(@class),' '),' CalendarCell ')][contains(.//div[@class='CalendarDayHeader MonthName'],'"+str(date)+"')]/div[contains(@class, 'CalendarDayEvents')]"
        else: 
            eventxpath = "//div[contains(@id,'layout-tabbox-groups')]/div[contains(@style,'display: block')]//td[contains(concat(' ',normalize-space(@class),' '),' CalendarCell ')][contains(.//div[@class='CalendarDayHeader'],'"+str(date)+"')]/div[contains(@class, 'CalendarDayEvents')]"
        print(eventxpath)
        wait.until(EC.presence_of_element_located((By.XPATH, eventxpath)))
        #wait until the specified day has been found
        print("# of collumns with this date found: " + str(len(browser.find_elements_by_xpath(eventxpath))) + "  Note: this should only ever be 1")
        #print number of days found
        eventlist = browser.find_element_by_xpath(eventxpath)
        #set the web element holding all the events to a variable
        allevents = eventlist.find_elements_by_xpath("./*")
        #get all the seperate web elements holding the events and adds them to a list
        print("# of events found: " + str(len(allevents)))
        #print the number of events found'
        #for event in allevents:
        #    print(event.get_attribute("innerHTML"))
        eventnum = 0
        eventcount = 0       
        availbefore = ""
        availafter = "" 
        if len(allevents) == 1:
            availbefore = "OPEN"
            availafter = "OPEN"
        else:
            print("looking for original event")
            print("original event start time: " + str(start))
            print("original event end time: " + str(end))
            for event in allevents:
                load()
                starttime = event.find_element_by_xpath("./span[1]").get_attribute("innerText")
                print("found start time: " + starttime)
                if len(starttime) > 8:
                    #
                    # come back here later to parse long term memes
                    #
                    datestart = starttime[7:].replace("(", "").replace(")", "")
                    starttime = datetime.datetime.strptime(starttime[:7].strip().upper(), "%I:%M%p")
                    print("date start: " + datestart)
                else:
                    starttime = datetime.datetime.strptime(starttime.upper(), "%I:%M%p")
                print("reformat start time: " + str(starttime))
                endtime = event.find_element_by_xpath("./span[2]").get_attribute("innerText")
                print("found end time: " + endtime)
                if len(endtime) > 8:
                    #
                    # come back here later to parse long term memes
                    #
                    endtime = datetime.datetime.strptime(endtime[:7].strip().upper(), "%I:%M%p")
                else:
                    endtime = datetime.datetime.strptime(endtime.upper(), "%I:%M%p")
                print("reformat end time: " + str(endtime))
                if(starttime == start and endtime == end):
                    print("found room")
                    eventnum = eventcount
                    break
                eventcount += 1
            if eventnum > 0:
                endtime = allevents[eventnum-1].find_element_by_xpath("./span[2]").get_attribute("innerText")
                if len(endtime) > 8:
                    #
                    # come back here later to parse long term memes
                    #
                    endtime = datetime.datetime.strptime(endtime[:7].strip().upper(), "%I:%M%p")
                else:
                    endtime = datetime.datetime.strptime(endtime.upper(), "%I:%M%p")
                #endtime = datetime.time.strftime(endtime, "%I:%M%p")
                #availbefore = str(endtime) + " - " + nstart
                availbefore = endtime;
            else:
                availbefore = "OPEN"
            if eventnum < len(allevents) - 1:
                starttime = allevents[eventnum+1].find_element_by_xpath("./span[1]").get_attribute("innerText")
                if len(starttime) > 8:
                    #
                    # come back here later to parse long term memes
                    #
                    datestart = starttime[7:].replace("(", "").replace(")", "")
                    starttime = datetime.datetime.strptime(starttime[:7].strip().upper(), "%I:%M%p")
                    print("date start: " + datestart)
                else:
                    starttime = datetime.datetime.strptime(starttime.upper(), "%I:%M%p")
                #starttime = datetime.time.strftime(starttime, "%I:%M%p")
                #availafter =  nend + " - " + str(starttime)
                availafter = starttime; 
            else:
                availafter = "OPEN"
        return [availbefore, availafter]
    else:
        print("failure to search");
        return ["check manually", "check manually"]

#generic class for switching tabs
def changetab(name):
    print("Switching tab to: " + name)
    clickid("s25-tabitem-" + name)

#specific tab for going to the "events" tab
def goevents():
    changetab("events")
    clickxpath('//*[@title="Pre-Defined Event Searches"]')
    clickxpath("//div[contains(@class, 'browse_area') and contains(.//div, 'All of Your Event Searches')]")
    clickxpath("//*[text()='[Copy] OIT Events']")
    clickclass("btnSearch")
    morelocations()

#clicks a specific id
def clickid(id):
    toclick = wait.until(EC.presence_of_element_located((By.ID, id)))
    wait.until(EC.element_to_be_clickable((By.ID, id)))
    clickload(toclick, id)

#clicks the first element of a specific class
def clickclass(classn):
    toclick = wait.until(EC.presence_of_element_located((By.CLASS_NAME, classn)))
    wait.until(EC.element_to_be_clickable((By.CLASS_NAME, classn)))
    clickload(toclick, classn)

#clicks the first element of a specific event
def clickfromevent(event):
    toclick = event.find_element_by_class_name("summary")
    clickload(toclick, "summary")

#clicks the first element of a specific xpath
def clickxpath(xpath):
    toReturn = waitForXPath(xpath)
    toclick = wait.until(EC.visibility_of_element_located((By.XPATH, xpath)))
    wait.until(EC.element_to_be_clickable((By.XPATH, xpath)))
    clickload(toclick, xpath)
    return toReturn

#more in-depth click command which ensures the page isn't loading both before and after
def clickload(toclick, click):
    load()
    print("clicking " + click)
    loadingstill = True
    while loadingstill:
        try:
            toclick.click()
            print("clicked!")
        except:
            load()
            print("click failed! " + click)
        else:
            loadingstill = False
    load()

# ensures that all locations are visible before the list of events is generated
def morelocations():
    load()
    wait.until(EC.visibility_of_element_located((By.XPATH, "//*[contains(@class, 'MonthCalendarTable')][not(contains(@class, 'ngSize100'))]")))
    elements = browser.find_elements_by_class_name("Calendar_ShowMore")
    print("expanding locations: " + str(len(elements)))
    for more in elements:
        more.click()
        load()

import openpyxl
import datetime
from openpyxl.formatting.rule import ColorScaleRule

def writexl(events, numbercc):
    print("creating excel spreadsheet")
    workbook = openpyxl.load_workbook('template.xlsm', keep_vba=True)
    worksheet = workbook.active
    r = 2
    for event in events:
        print(str(event.classroom[0]))
        # Room = B2
        # Cart = C2
        # Laptop = E2
        # Clicker = F2
        # Wireless Presenter = G2
        # Misc. = H2
        # Asset # = I2
        # Open Before = J2
        # Start Time = K2
        # Delivery Tech = L2
        # End Time = M2
        # Open After = N2
        # Pick Up Tech = O2
        # Notes = P2
        massres = ""
        if not event.resources:
            print("no resources found")
        else:
            worksheet["B" + str(r)] = event.classroom[0]
            for resource in event.resources:
                if "Computer / Dell Laptop" in resource:
                    worksheet["D" + str(r)] = "X"
                elif "Wireless Presenter" in resource:
                    worksheet["G" + str(r)] = "X"
                elif "Mobile Lab" in resource:
                    worksheet["E" + str(r)] = "X"
                elif "Projector" in resource:
                    worksheet["C" + str(r)] = "X"
                elif "Clickers" in resource:
                    if "25" in resource:
                        worksheet["F" + str(r)] = "25"
                    elif "50" in resource:
                        worksheet["F" + str(r)] = "50"
                    else:
                        worksheet["F" + str(r)] = resource
                else:
                    massres += resource
                    worksheet["H" + str(r)] = massres
            instructionstring = ""
            event.instructions = list(set(event.instructions))
            if len(event.instructions) > 1:
                for instruction in event.instructions:
                    instructionstring += instruction + " - "
                worksheet["P" + str(r)] = instructionstring
            elif len(event.instructions) < 1:
                print("no instructions!")
            else:
                worksheet["P" + str(r)] = event.instructions[0]
            if True:
                if isinstance(event.availbefore, str):
                    worksheet["J" + str(r)] = event.availbefore;
                else:
                    print(event.availbefore)
                    tbefore = stripX(datetime.datetime.strftime(ceil_dt(event.availbefore, 15), "X%I:%M")).replace(":00", "")
                    tstart = stripX(datetime.datetime.strftime(floor_dt(event.starttime, 15), "X%I:%M")).replace(":00", "")
                    if tbefore == tstart:
                        worksheet["J" + str(r)] = "@ " + tstart
                    else:
                        teta = tbefore + " - " + tstart
                        if event.availbefore > event.starttime:
                            teta += " (overlap, check manually)"
                        worksheet["J" + str(r)] = teta
                if isinstance(event.availafter, str):
                    worksheet["N" + str(r)] = event.availafter;
                else:
                    print(event.availafter)
                    tafter = stripX(datetime.datetime.strftime(floor_dt(event.availafter, 15), "X%I:%M")).replace(":00", "")
                    tend = stripX(datetime.datetime.strftime(ceil_dt(event.endtime, 15), "X%I:%M")).replace(":00", "")
                    if tend == tafter:
                        worksheet["N" + str(r)] = "@ " + tend
                    else:
                        teta = tend + " - " + tafter
                        if event.availafter < event.endtime:
                            teta += " (overlap, check manually)"
                        worksheet["N" + str(r)] = teta
            else:
                print("bad coding")
            numberformattime = 'h:mm AM/PM'
            startvalue = floor_dt(event.starttime, 15).time()
            startcell = worksheet["K" + str(r)]
            startcell.value = startvalue
            startcell.number_format = numberformattime
            endvalue = ceil_dt(event.endtime, 15).time()
            endcell = worksheet["M" + str(r)]
            endcell.value = endvalue
            endcell.number_format = numberformattime
            r += 1
    workbook.save(month + " " + str(date) + " " + str(numbercc) + ".xlsm")
    print("saved! as " + month + " " + str(date) + " " + str(numbercc) + ".xlsm")


from tkinter import *
from tkinter import messagebox


def start():
    username = gui.uEntry.get()
    password = gui.pEntry.get()
    global date
    date = gui.dSpinbox.get()
    if username:
        if password:
            try:
                global browser
                global wait
                delay = 10
                if gui.bstring.get() == 1:
                    browser = webdriver.Firefox()
                elif gui.bstring.get() == 2:
                    browser = webdriver.Chrome()
                else:
                    print("no browser available")
                wait = WebDriverWait(browser, delay)
                browser.get('https://25live.collegenet.com/delta/')
                signin(username, password)
            except TimeoutException:
                print("Loading took too much time!")
                sys.exit()
            goevents()
            setuparray()
            opentimes()
            writexl(events, 999)
        else:
            print("no password!")
    else:
        print("no username!")

class LoginGUI:
    def __init__(self, master):
        self.master = master
        master.title("AV Delivery Spreadsheet Generator")

        self.uLabel = Label(master,text="username")
        self.uLabel.pack(padx=10)

        self.uEntry = Entry(master)
        self.uEntry.pack(padx=10)

        self.pLabel = Label(master,text="password")
        self.pLabel.pack(padx=10)

        self.pEntry = Entry(master, show='*')
        self.pEntry.pack(padx=10)

        self.dLabel = Label(master,text="date")
        self.dLabel.pack(padx=10)

        self.dSpinbox = Spinbox(master, from_=1, to=31)
        self.dSpinbox.pack(padx=10)

        self.bstring = IntVar()
        self.fRadio = Radiobutton(master, text="FireFox", variable=self.bstring, value=1).pack()
        self.cRadio = Radiobutton(master, text="Chrome", variable=self.bstring, value=2).pack()

        self.lButton = Button(master, text="start", command=start)
        self.lButton.pack()

warningmsg = "Remember to print the Report and check the OPEN times before and after. There are some things the program doesn't take into account, either because it doesn't have support for something, is broken somewhere, or doesn't handle oddly-made requests properly. If there are any descrepancies, fix them on the spreadsheet and let me (Roger) know about them. That goes double for the before-OPEN and after-OPEN times. The algorithm behind that is a lot more complex, and that means it's a lot easier to break. If there are any issues with the spreadsheet and something doesn't get delivered on time, I take no responsibility."

root=Tk()
gui = LoginGUI(root);
messagebox.showinfo("Warning", warningmsg)
root.focus_force()

root.mainloop()

#if it can sign in, continue. if not, fail

